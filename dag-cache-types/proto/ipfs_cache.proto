syntax = "proto3";

package ipfscache;

service IpfsCache {
  // get a node, return it plus any children of that node reachable via the in-memory cache
  rpc GetNode(IpfsHash) returns (GetResp) {}

  rpc GetNodes(IpfsHash) returns (stream IpfsNode) {}

  rpc PutNode(IpfsNode) returns (IpfsHash) {}

  // TODO: mb figure out how to do as stream? nah, would remove ability to validate before any ipfs uploads performed
  rpc PutNodes(BulkPutReq) returns (IpfsHash) {}
}



message GetResp {
  IpfsNode requested_node = 1;
  uint64 extra_node_count = 2;
  repeated IpfsNodeWithHeader extra_nodes = 3;
}

message IpfsNodeWithHeader {
    IpfsHeader header = 1;
    IpfsNode node = 2;
}


message BulkPutReq {
  BulkPutIpfsNode root_node = 1; // invariant: must be in list of nodes
  repeated BulkPutIpfsNodeWithHash nodes = 2;
}

message BulkPutLink {
  oneof link {
    IpfsHeader in_ipfs = 1;
    ClientId in_req = 2;
  }
}

message BulkPutIpfsNodeWithHash {
  ClientId client_side_hash = 1;
  BulkPutIpfsNode node = 2;
}

message BulkPutIpfsNode {
  bytes data = 1;
  repeated BulkPutLink links = 2;
}

message ClientId {
  string hash = 1; // some string, should be unique id (eg u128 uuid)
}



message IpfsHash {
  string hash = 1; // base58 encoded string, to simplify grpc gui interactions
}

message IpfsHeader {
  string name = 1; // using this naming scheme so clients can do lazy diffing w/o having to upload a whole tree
  IpfsHash hash = 2;
  uint64 size = 3;
}

message IpfsNode {
  bytes data = 1;
  repeated IpfsHeader links = 2;
}