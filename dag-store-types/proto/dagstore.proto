syntax = "proto3";

package dagstore;

service DagStore {
  // get a node, return it plus any children of that node reachable via the in-memory cache
  rpc GetNode(Hash) returns (GetResp) {}

  // get nodes, using provided javascript to decide which subnodes to traverse and return
  rpc GetNodes(Hash) returns (stream Node) {}

  rpc PutNode(Node) returns (Hash) {}

  rpc PutNodes(BulkPutReq) returns (BulkPutResp) {}
}

message GetNodeReq {
  Hash hash = 1;
  string filter_fn = 2;
}

message GetHashForKeyReq {
  string key = 1;
}

message GetHashForKeyResp {
  Hash hash = 1;
}

message GetResp {
  Node requested_node = 1;
  uint64 extra_node_count = 2;
  repeated NodeWithHeader extra_nodes = 3;
}

message NodeWithHeader {
    Header header = 1;
    Node node = 2;
}

message BulkPutReq {
  BulkPutNode root_node = 1;
  repeated BulkPutNodeWithHash nodes = 2;
}

message BulkPutResp {
  Hash root_hash = 1;
  repeated BulkPutRespPair additional_uploaded = 2;
}

message BulkPutRespPair {
  Hash hash = 1;
  Id client_id = 2;
}

message BulkPutLink {
  oneof link {
    Header in_store = 1;
    Id in_req = 2;
  }
}

message BulkPutNodeWithHash {
  Id client_side_hash = 1;
  BulkPutNode node = 2;
}

message BulkPutNode {
  bytes data = 1;
  repeated BulkPutLink links = 2;
}

message Id {
  bytes id = 1; // [u8; 16], big-endian u128
}

message Hash {
  bytes hash = 1; // [u8; 32], blake3 output
}

message Header {
  Id id = 1;
  Hash hash = 2;
}

message Node {
  bytes data = 1;
  repeated Header links = 2;
}
