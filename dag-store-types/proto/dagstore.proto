syntax = "proto3";

package dagstore;

service DagStore {
  // get a single node
  rpc GetNode(Hash) returns (Node) {}

  // get nodes, using provided matcher fn to decide which subnodes to traverse and return
  // returns GetNodesResp, either nodes or nodes we chose not to traverse
  rpc GetNodes(Hash) returns (stream GetNodesResp) {}

  rpc PutNode(Node) returns (Hash) {}

  rpc PutNodes(BulkPutReq) returns (Hash) {}
}

// TODO: use this instead of just a hash for getnodes, but only AFTER I have some working proptests
message GetNodesReq {
  Hash hash = 1;
  oneof matcher {
    string string_matcher = 2;
    // TODO: enum, some javascript used to filter metadata 
  }
}

message GetNodesResp {
  oneof link {
    Header chose_not_to_traverse = 1;
    NodeWithHash node_response = 2;
  }
}


message NodeWithHash {
    Hash hash = 1;
    Node node = 2;
}

message BulkPutReq {
  BulkPutNode root_node = 1;
  repeated BulkPutNodeWithId nodes = 2;
}

message BulkPutLink {
  oneof link {
    Header in_store = 1;
    Id in_req = 2;
  }
}

message BulkPutNodeWithId {
  Id id = 1;
  BulkPutNode node = 2;
}

message BulkPutNode {
  bytes data = 1;
  repeated BulkPutLink links = 2;
}

message Id {
  uint32 id = 1;
}

message Hash {
  bytes hash = 1; // [u8; 32], blake3 output
}

message Header {
  Id id = 1;
  Hash hash = 2;
  string metadata = 3;
}

message Node {
  bytes data = 1;
  repeated Header links = 2;
}
